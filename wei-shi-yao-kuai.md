为什么快

资料 [https://studygolang.com/articles/26879?fr=sidebar](https://studygolang.com/articles/26879?fr=sidebar)

> 进程 系统进行资源分配的基本单位，有独立的内存空间
>
> 线程 cpu调度和分派的基本单位，线程依赖进程，共享父进程的 资源
>
> 协程   是用户态 的 轻量级线程，协程的调度完全由用户控制 。协程间切换只需要保存上下文，没有内核的开销

go为并发而生

协程非常轻量

> 内存占用少 线程栈空间2m，协程栈空间2k
>
> 上下文切换代价小  上下文且含涉及到3个寄存器，线程切换涉及到15个寄存器

GPM

> G保存运行堆栈，执行函数。可重用

协程阻塞

> 1 原子 互斥量 和通道操作导致的 阻塞，会被切出去，然后会去执行 LRQ的其他G
>
> 2 网络请求和io导致的 阻塞。会被切到网络轮训器等待异步结果。P处理其他的G。异步结果拿到后，重新加入P。不需要 额外的M
>
> 3 系统函数操作导致的阻塞，比如文件io，P会切换到新的M去执行剩余的任务，阻塞的系统调用完成后，G重新加入P
>
> 4  后台 执行sleep导致的阻塞。golong后台监视线程sysmon，会把它标记为可以强占，LRQ优先执行。等到这个G继续执行的时候，就会被强占，同时保护现场，重新加入P的队列等待下次执行



通过GPM实现少量线程支持大量的并发，并通过网络轮训器 和sysmon来减少线程的阻塞。充分利用 有限的线程资源 ，提高go的运行效率





