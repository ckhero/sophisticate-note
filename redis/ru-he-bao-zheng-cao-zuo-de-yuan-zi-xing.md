# 如何保证操作的原子性

## 资料

> [https://www.cnblogs.com/sunsky303/p/9164013.html](https://www.cnblogs.com/sunsky303/p/9164013.html)
>
> [https://www.cnblogs.com/number7/p/8320259.html](https://www.cnblogs.com/number7/p/8320259.html)



## lua 优点

> 减少网络开销:本来多次请求，可以用一个操作完成。原先请求多次的逻辑放在redis服务器上完成，使用脚本，减少了网络延迟往返时延
>
> ```
>     原子操作 : **redis将脚本作为一个整体去执行，中间不会被其他命令插入**
>
>    复用：客户端发送的脚本会永久存在redis中，意味着其他的客户端可以复用这一脚本而不需要y用代码实现同样的逻辑
> ```

## multi 执行过程

> 每发送一条，都要单独发送给服务器。服务器再单独返回“该条指令已加入队列”，所以比pipline慢
>
> multi执行的会暂停其他命令的执行，类似加了一个锁。直到整个multi结束再继续其他的客户端的请求。这是multi保证一致性的原因

## watch

> multi 之前 watch一个key，exec的时候如果这个key发生变化，事务回滚。利用的CAS思想

## pipeline

> 打包发送命令。服务端不接受类似已收到的命令，而是批量执行所有命令。成功后直接返回结果
>
> 服务端处理命令是不需要加锁的。而是与其他的客户端命令混合再一起，所以无法保证一致性

## lua + multi

**两者的区别**

> redis将lua脚本当做一个整体去执行，multi会暂停其他命令，类似加锁。所以lua脚本效率更高



