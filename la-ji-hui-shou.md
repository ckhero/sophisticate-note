# 垃圾回收

## 资料

> [http://legendtkl.com/2017/04/28/golang-gc/](http://legendtkl.com/2017/04/28/golang-gc/)
>
> [https://studygolang.com/articles/27243?fr=sidebar](https://studygolang.com/articles/27243?fr=sidebar)

* ## v1.1 STW

> 标记-清除 会刮起用户程序

* ## v1.3 Mark STW, Sweep 并行

> 标记-清除，标记阶段挂起，清除并行

* ## v1.5 三色标记法

> 1. 把可达对象标记为灰色放入待处理队列
> 2. 把灰色标记为黑色，并且把灰色的可达对象标记为灰色
> 3. 重复1，2直到没有灰色对象
>
> 问题：标记过程会挂起用户程序，因为如果标记过程中有白色对象被黑色对象引用的话，会被清除

### 解决

> **原理**
>
> * 强三色不变  不存在黑色对象应用到白色对象的指针
> * 弱三色不变 所有被黑色对象引用的白色对象都处于被灰色对象保护
>
> **操作**
>
> * 插入屏障  a对象引用b对象，b对象标记为灰色  满足 强三色
> * 删除屏障 被删除的对象，如果本身是灰色或者白色，标记为 灰色
>
> **短板**
>
> * 插入屏障  因为只针对堆内的对象，所有标记结束后需要STW处理栈内的白色对象
> * 删除屏障 回收精度降低

* ## v1.8 hybrid write barrier\(混合写屏障：优化STW\)

> * 栈内的对象全部标记为黑色
> * 栈内新增的对象标记为黑色
> * 被删除的对象标记为黑色
> * 被新增的对象标记为黑色

## 栈和堆分开处理原因

> 栈空间的特点是容量小，但是要求响应速度快，因为 函数调用弹出频繁，所有插入屏障机制在栈空间的对象中不适用



