MQ

[https://blog.csdn.net/wqc19920906/article/details/82193316](https://blog.csdn.net/wqc19920906/article/details/82193316)

模式资料 [https://www.cnblogs.com/diandianquanquan/p/11966668.html](https://www.cnblogs.com/diandianquanquan/p/11966668.html)

四大mq对比 [https://blog.csdn.net/wqc19920906/article/details/82193316](https://blog.csdn.net/wqc19920906/article/details/82193316)

## 四种模型

> 1.PTP\(点对点\)
>
> 基于队列，一个队列可以有多个生产者多个消费者。一条消息只能被一个消费者消费，消费后会被移除。服务器按照收到消息的先后顺序入队
>
> 在多个消费者的时候为了提升消费能力，会将消息发送给不同的消费者，这样子导致消息的消费是无序的。为了解决这个问题，提出专有消费者的概念。（RocketMq）队列的消息的只能由一个消费者去消费。多个消费者的时候从中选择一个。这意味着消息处理没有了并行性。消息很多的情况下会导致消息积压
>
> 2.PUB/SUB\(发布/订阅\)
>
> 生产者把消息发送到一个主题下面，订阅主题的所有消费者都会收到这条消息。
>
> 3.Partion\(分区\)
>
> 为了解决PTP专有消费者带来的性能问题。rabbitMq和kafka采用了分区的模型。每个分区存储部分数据。对于消费者多了一个消费者组的概念。分区会在同一个消费者组下的消费者进行分配。每个消费者只会消费对应的分区。也有可能一个消费者分配到多个分区。
>
> 同一个主题下面的消息可以被不同的消费者组消费
>
> 最大弊端，消费者数量不能超过分区数量
>
> 4.transfer
>
> GO语言编写的NSQ消息中间件采用的这种模式
>
> 分区的概念换成channel的概念。channel保存了全量数据，只记录了消息的一些元数据，不是真正的消息体。一个channel可以同时被不同的消费者消费。这些x消费者自动组成一个消费者组，不能保证消息有序。除非通过 专有消费者的概念

## 两大问题？

> * 消息顺序消费
> * 消息的精确投放

## 消息系统语义？

> * 至少一次
>
> 至少成功一次，会出现broker发送给生产者确认消息的时候出错了。生产者勿认为没有送成功，重试再发。产生两条消息
> * 至多一次
>
> 生产者发送消息给broker的时候出错了。broker未收到消息。生产者认为已经收到了
> * 精确一次
>
> 生产者在出错的时候，会重试，但是只产生一条消息。需要消息系统和客户端系统配合



